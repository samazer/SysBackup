<?php /* -*- mode: php; mode: mmm; coding: utf-8-unix; -*- */
/**
 *
 * General tarball support
 *
 * This class is used to generate tarballs. The class is designed to
 * allow the calling software to specify a tool for making tarballs
 * (ie: usually tar or pax,) and, later, change the choice without
 * having to make any other changes to the calling software.
 *
 * Note the use of a separate gzip filter rather than using the
 * compression built into the tar/pax utility. This is because gzip
 * and other filters normally embed a time stamp and file name into
 * their output streams. As a result of this timestamp it is
 * impossible for two tarballs of the same collection of files to have
 * the same sha1 hash. To avoid this problem the tarball is generated
 * as uncompressed data and piped through the filter using an option
 * to suppress the timestamp info.
 *
 * This class consists of code extracted from the nightly-backup
 * utility, v2.
 *
 *
 * @todo: Add pax - it's not actually implemented yet.
 * @todo: Add 7z and other filters.
 *
 *
 * <p><b>Copyright</b>
 *
 * <p>Copyright (c) 2001-2011 by Sam Azer, All Rights Reserved.
 *
 * <p>This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * <p>This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * <p>You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 *
 * @author Sam Azer <sam@azertech.net>
 * @version 0.01 (alpha)
 * @package aforms
 * @subpackage lib-general
 * @license http://www.gnu.org/licenses/agpl.html AGPL
 * @copyright 2001-2011 by Sam Azer, All rights reserved
 * @link http://www.azertech.net/
 * @link http://www.samazer.net/about
 *
 */


/**
 *
 * ********** IMPORTANT ********************
 *
 * This is the string that your archive utility returns when a file is
 * changed during archiving. If this utility is able to detect the
 * FILECHANGED_TEXT in an error message it will issue a warning
 * instead of a fatal error. 
 *
 * If you prefer a fatal error you should change this text to read "do
 * not use."
 *
 * If your system is setup for another language it may use a different
 * string - so it is important to find out what string to use for your
 * locale and put it here.
 *
 */
define( "SYS_TAR_FILECHANGED_TEXT", "file changed" );



/**
 *
 * Names of the supported tarball-make tools
 *
 */
define( "SYS_CMD_TAR_NAME",     "tar" );
define( "SYS_CMD_PAX_NAME",     "pax" );
define( "SYS_CMD_GZIP_NAME",    "gzip" );


/**
 *
 * Binary path/filename of the supported tarball-make binaries
 *
 */
define( "SYS_CMD_TAR_BIN",     "/bin/tar" );
define( "SYS_CMD_PAX_BIN",     "/usr/bin/pax" );
define( "SYS_CMD_GZIP_BIN",    "/bin/gzip" );


/**
 *
 * Extension to use for tarball filenames
 *
 * This extension is added to tarball names generated by the backup
 * script. Use an extension based on the options you choose for the
 * tarball format and the type of compression (ie: .tar.gz, .tar.bz2,
 * .tar.7z, etc. or .pax.gz, .pax.bz2, .pax.7z, etc.)
 *
 */
define( "SYS_CMD_TAR_EXT",      ".tgz" );
define( "SYS_CMD_PAX_EXT",      ".pgz" );
define( "SYS_CMD_GZIP_EXT",     ".gz"  );


/**
 *
 * Default options that are always passed to the tar utility
 * 
 * See the Tar command for an example of Parameter Substitution
 *
 * @see SYS_CMD_TAR
 *
 */
define( "SYS_CMD_TAR_DEFAULTOPTS",    "--preserve-order --preserve-permissions --atime-preserve=system" );
define( "SYS_CMD_PAX_DEFAULTOPTS",    "-w -t" );
define( "SYS_CMD_GZIP_DEFAULTOPTS",   "--no-name" );

/**
 *
 * Options to pass to the tar utility
 * 
 * See the Tar command for an example of Parameter Substitution
 *
 * @see SYS_CMD_TAR
 *
 */
define( "SYS_CMD_TAR_OPTS1",    "" );

/**
 *
 * Options to pass to the tar utility
 *
 * See the Tar command for an example of Parameter Substitution
 *
 * @see SYS_CMD_TAR
 *
 */
define( "SYS_CMD_TAR_OPTS2",    "" );

/**
 *
 * Options to pass to the tar utility
 *
 * See the Tar command for an example of Parameter Substitution
 *
 * @see SYS_CMD_TAR
 *
 */
define( "SYS_CMD_TAR_OPTS3",    "" );


/**
 *
 * Options to pass to the compression filter
 *
 */
define( "SYS_CMD_GZIP_OPTS1",   "" );


/**
 *
 * File Name of the tar utility to use
 *
 * <p>Note that this is not a simple choice. There are a long list of
 * tools available for making tarballs on a typical unix system. The
 * one you want to use is not necessarily tar. The issues involved are
 * not always simple or obvious. Users of Redhat derived Linux
 * distros, for example, will want to consider how they will restore
 * SELinux context info in case of disaster.
 *
 * <p>The best way to ensure that you made the right choice is to
 * write a test plan for your server, build a VM, restore a backup
 * onto it and execute the test plan. Once you've completed this
 * exercise you will have a better idea of the issues involved. Don't
 * forget to go back and repeat the exercise!! It's tedius but you
 * will need to keep doing it until there are no remaining issues to
 * resolve.
 *
 * <P>Parameter substitution is used:
 *
 * <ul>
 *
 * <li><b>%SOURCE%</b> is replaced with the path to the directory to
 * be tarballed
 *
 * <li><b>%TARGET%</b> is replaced with the path and filename of the
 * target file. This filename is automatically generated and has
 * the SYS_CMD_TAR_EXT filename extension appended to it.
 *
 * <li><b>%OPTSn%</b> (ie: %OPTS1% through %OPTS3%) are replaced with
 * the corresponding texts defined in SYS_CMD_TAR_OPTSn.
 *
 * </ul>
 *
 * <p><pre>
 *
 * <p>The resulting command line might look like this, for example:
 *
 * <p><pre>/bin/tar --preserve -zcf var-spool-mail.tgz /var/spool/mail</pre>
 *
 */

define( "SYS_CMD_TAR", SYS_CMD_TAR_BIN . " "
                     . SYS_CMD_TAR_DEFAULTOPTS . " "
                     . "%OPTS1% --create %OPTS2% '%SOURCE%' %OPTS3% "
        );

define( "SYS_CMD_PAX", SYS_CMD_PAX_BIN . " "
                     . SYS_CMD_PAX_DEFAULTOPTS . " "
                     . "%OPTS1% %OPTS2% '%SOURCE%' %OPTS3% "
        );

define( "SYS_CMD_GZIP_FILTER", SYS_CMD_GZIP_BIN . " "
                             . SYS_CMD_GZIP_DEFAULTOPTS 
                             . "%OPTS1% >'%TARGET%'"
        );

define( "SYS_CMD_GZIP_FILE", SYS_CMD_GZIP_BIN . " "
                           . SYS_CMD_GZIP_DEFAULTOPTS 
                           . "%OPTS1% <'%SOURCE%' >'%TARGET%'"
        );


require_once "general-sysutils.inc";
require_once "general-sysexec.inc";



class mktarball_util_c 
{
   var $tar_name     = "tar";
   var $tar_bin      = SYS_CMD_TAR_BIN;
   var $tar_ext      = SYS_CMD_TAR_EXT;

   var $tar_defopts  = SYS_CMD_TAR_DEFAULTOPTS;
   var $tar_opts1    = SYS_CMD_TAR_OPTS1;
   var $tar_opts2    = SYS_CMD_TAR_OPTS2;
   var $tar_opts3    = SYS_CMD_TAR_OPTS3;

   var $tar_cmd      = SYS_CMD_TAR;

   var $gzip_name    = "gzip";
   var $gzip_bin     = SYS_CMD_GZIP_BIN;
   var $gzip_ext     = SYS_CMD_GZIP_EXT;

   var $gzip_defopts = SYS_CMD_GZIP_DEFAULTOPTS;
   var $gzip_opts1   = SYS_CMD_GZIP_OPTS1;

   var $gzip_filter  = SYS_CMD_GZIP_FILTER;
   var $gzip_file    = SYS_CMD_GZIP_FILE;

   var $distro;
   var $last_errmsg  = "";

   var $last_output  = array(); // copy of last exec output. used when debugging.

   var $debug_sysexec;         // true to view the commands that are exec'd

   var $named_parameters;


   function __construct()
   {
      $this->debug_sysexec = false;

      // not really using this yet:
      // $this->distro = new linux_distro_c();
      $this->named_parameters = new named_parameters_c( "system", "mktarball_util" );

      $this->named_parameters->register( "mktarball", "base", array(

         "tar_name"     => array( true,  "Name of the tar-like utility to use" ),
         "tar_bin"      => array( true,  "path/filename of the executable" ),
         "tar_ext"      => array( true,  "extension to use for this type of tarball" ),

         "tar_defopts"  => array( true,  "default options to pass always" ),
         "tar_opts1"    => array( false, "additional options 1" ),
         "tar_opts2"    => array( false, "additional options 2" ),
         "tar_opts3"    => array( false, "additional options 3" ),

         "tar_cmd"      => array( true,  "command string (replacing %BINARY%, %DEFOPTS%, %OPTS1/2/3%, %SOURCE% & %TARGET%)" ),

         "gzip_name"    => array( true,  "Name of the gzip-like filter utility to use" ),
         "gzip_bin"     => array( true,  "path/filename of the executable" ),
         "gzip_ext"     => array( true,  "extention to use for this type of compressed file" ),

         "gzip_defopts" => array( true,  "default options to pass always to the filter" ),
         "gzip_opts1"   => array( false, "additional options to pass to the filter" ),

         "gzip_filter"  => array( true,  "filter command (replacing %BINARY%, %DEFOPTS%, %OPTS1/2/3%, %SOURCE% & %TARGET%)" ),
         "gzip_file"    => array( true,  "file command (replacing %BINARY%, %DEFOPTS%, %OPTS1/2/3%, %SOURCE% & %TARGET%)" ),

      ));
   }


   function set_debugsysexec( $flg = -1 )
   {
      if ( $flg === -1 )
         return $this->debug_sysexec;

      return $this->debug_sysexec = $flg;
   }


   function setup( $opts )
   {
      $this->named_parameters->check( "mktarball", "base", $opts );
      $this->named_parameters->set_properties( $this, "mktarball", "base", $opts );
   }


   function dump_config()
   {
      $this->named_parameters->tee( "Compression Options:" );

      $this->named_parameters->display_properties( $this, 
                                                   "mktarball", 
                                                   "base" );
      $this->named_parameters->tee("");
   }


   function last_error( $t = false, $append_flag = false )
   {
      if ( $t === false )
         return $this->last_errmsg;

      if ( $append_flag )
         $this->last_errmsg = $this->last_errmsg 
                            . ($this->last_errmsg > "" ? "\n---\n" : "") 
                            . $t;
      else $this->last_errmsg = $t;

      return $t;
   }


   function _build_tar_cmd( $target, $source, $options )
   {
      $opts1  = $this->tar_opts1;
      $opts2  = $this->tar_opts2;
      $opts3  = $this->tar_opts3;

      if ( isset( $options["exclude"] ) )
      {
         // $options["exclude"] = array( "dir1", "dir2", "dir3", ... );
         $ex = "";
         foreach( $options["exclude"] as $p )
            $ex = $ex
                . ($ex > "" ? " " : "")
                . "--exclude='{$p}'"
                ;

         $opts3 = "{$ex} {$opts3}";
      }

      $params = array( "%BINARY%"  => $this->tar_bin,
                       "%DEFOPTS%" => $this->tar_defopts,
                       "%OPTS1%"   => $opts1,
                       "%OPTS2%"   => $opts2,
                       "%OPTS3%"   => $opts3,
                       "%SOURCE%"  => $source,
                       "%TARGET%"  => $target,
                     );

      $cmd = "exec " . $this->tar_cmd;
      foreach ( $params as $txt => $val )
         $cmd = str_replace( $txt, $val, $cmd );

      return $cmd;
   }


   function _build_gzip_cmd( $target, $source, $options, $filter = true )
   {
      $opts1  = $this->tar_opts1;

      $params = array( "%BINARY%"  => $this->gzip_bin,
                       "%DEFOPTS%" => $this->gzip_defopts,
                       "%SOURCE%"  => $source,
                       "%TARGET%"  => $target,
                       "%OPTS1%"   => $opts1,
                     );

      $cmd = "exec " . ($filter ? $this->gzip_filter : $this->gzip_file);
      foreach ( $params as $txt => $val )
         $cmd = str_replace( $txt, $val, $cmd );

      return $cmd;
   }


   function _build_tarball_cmd( $target, $source, $options = array() )
   {
      switch ( $this->tar_name )
      {
         case "tar":
            return $this->_build_tar_cmd( $target, $source, $options );

         case "pax":
            return $this->_build_pax_cmd( $target, $source, $options );

         default:
            // don't know the tarballing util
            $this->last_error( "unknown tarballing utility: {$this->tar_name}" );
            return false;
      }

      // script engine error?
      $this->last_error( "an unexpected error was detected", true );
      return false;
   }


   function _build_compression_filter_cmd( $target, $source, $options = array() )
   {
      switch ( $this->gzip_name )
      {
         case "gzip":
            return $this->_build_gzip_cmd( $target, $source, $options );

         default:
            // don't know the compression util
            $this->last_error( "unknown compression utility: {$this->gzip_name}" );
            return false;
      }

      // script engine error?
      $this->last_error( "an unexpected error was detected", true );
      return false;
   }


   function _build_compress_file_cmd( $target, $source, $options = array() )
   {
      switch ( $this->gzip_name )
      {
         case "gzip":
            return $this->_build_gzip_cmd( $target, $source, $options, false );

         default:
            // don't know the compression util
            $this->last_error( "unknown compression utility: {$this->gzip_name}" );
            return false;
      }

      // script engine error?
      $this->last_error( "an unexpected error was detected", true );
      return false;
   }


   private function _eval_funny_exitcodes( $r )
   {
      if ( $r["exitcode"] )
         $this->last_error( trim($r["stderr"]), true );

      /**
       * gzip is supposed to return a standard error result (ie: 0 =
       * good, non-zero = bad.) 
       *
       * Unfortunately the practical experience is that exit codes are
       * not as reliable as they should be. At the time of this
       * writing the reason for the problems is not known. Sometimes
       * the exitcode is -1 even though the filter completed
       * successfully.
       *
       * Another observation: Usually the proc_close return value is
       * -1 and the process exit code is 0. In many cases these values
       * seem to be reversed for no apparent reason.
       */

      if ( ($r["proc_close"] == -1)
        && ($r["exitcode"] == 0) )
         return 0;

      if ( ($r["proc_close"] == 0)
        && ($r["exitcode"] == -1) )
         return 0;

      if ( ($r["stderr"] == "")
        && ($r["exitcode"] == -1) 
         )
         return 0;

      return $r["exitcode"];
   }


   function _eval_tar_exitcode( $r )
   {
      return $this->_eval_funny_exitcodes( $r );
   }


   function _eval_gzip_exitcode( $r )
   {
      return $this->_eval_funny_exitcodes( $r );
   }


   function _eval_tarballer_exitcode( $r )
   {
      switch ( $this->tar_name )
      {
         case "tar":
            return $this->_eval_tar_exitcode( $r );

         case "pax":
            return $this->_eval_pax_exitcode( $r );

         default:
            // don't know the tarballing util
            return false;
      }

      // script engine error?
      $this->last_error( "an unexpected error was detected", true );
      return false;
   }


   function _eval_compression_filter_exitcode( $r )
   {
      switch ( $this->gzip_name )
      {
         case "gzip":
            return $this->_eval_gzip_exitcode( $r );

         default:
            // don't know the compression util
            return false;
      }

      // script engine error?
      $this->last_error( "an unexpected error was detected", true );
      return false;
   }


   function tarball_ext()
   {
      return $this->tar_ext;
   }


   function tarball_type()
   {
      return $this->tar_name;
   }


   function compressor_ext()
   {
      return $this->gzip_ext;
   }


   function compressor_type()
   {
      return $this->gzip_name;
   }


   function last_exec_result( $reset = false )
   {
      if ( $reset === false )
         return $this->last_output;

      $this->last_output = array();
      return false;
   }


   function command( $cmd, $target, $options = array() )
   {
      $this->last_error("");

      if ( ($filter = $this->_build_compression_filter_cmd( $target, "", $options )) === false )
         return true; // error 

      $output = array();
      if ( ($r = sysfilter( $output, $cmd, $filter, $options )) !== false )
      {
         $this->last_error( "unable to exec processes:\n"
                          . "Tar Command: \"{$cmd}\"\n"
                          . "Compression filter: \"{$filter}\"\n", true );
         // failed
         return $r;
      }

      $this->last_output = $output;

      if ( $this->debug_sysexec )
      {
         $this->named_parameters->tee( "SysExec'd: \"{$output[0]['command']}\"" );
         $this->named_parameters->tee( "Filtered: \"{$output[1]['command']}\"" );
      }

      $output[0]["evald_exitcode"] = $this->_eval_tarballer_exitcode( $output[0] );
      $output[1]["evald_exitcode"] = $this->_eval_compression_filter_exitcode( $output[1] );

      return $output[0]["evald_exitcode"]
          || $output[1]["evald_exitcode"]
             ;
   }


   function folder( $target, $source, $options = array() )
   {
      $this->last_error("");

      if ( !file_exists( $source ) )
      {
         $this->last_error( "folder {$source} not found" );
         return true;
      }

      if ( !is_readable( $source ) )
      {
         $this->last_error( "folder {$source} is not readable" );
         return true;
      }

      if ( ($cmd = $this->_build_tarball_cmd( $target, $source, $options )) === false )
         return true; // error 

      if ( ($filter = $this->_build_compression_filter_cmd( $target, $source, $options )) === false )
         return true; // error 

      $output = array();
      if ( ($r = sysfilter( $output, $cmd, $filter, $options )) !== false )
      {
         $this->last_error( "unable to exec processes:\n"
                          . "Tar Command: \"{$cmd}\"\n"
                          . "Compression filter: \"{$filter}\"\n", true );
         // failed
         return $r;
      }

      $output[0]["evald_exitcode"] = $this->_eval_tarballer_exitcode( $output[0] );
      $output[1]["evald_exitcode"] = $this->_eval_compression_filter_exitcode( $output[1] );

      $this->last_output = $output;

      if ( $this->debug_sysexec )
      {
         $this->named_parameters->tee( "SysExec'd: \"{$output[0]['command']}\"" );
         $this->named_parameters->tee( "Filtered: \"{$output[1]['command']}\"" );
      }

      return $output[0]["evald_exitcode"]
          || $output[1]["evald_exitcode"]
             ;
   }


   function file( $target, $source, $options = array() )
   {
      $this->last_error("");

      if ( ($filecmd = $this->_build_compress_file_cmd( $target, $source, $options )) === false )
         return true; // error 

      $output = array();
      if ( ($r = sysexec( $output, $filecmd, $options )) !== false )
      {
         $this->last_error( "unable to exec process: \"{$filecmd}\"\n", true );

         // failed
         return $r;
      }

      $this->last_output = $output;

      if ( $this->debug_sysexec )
         $this->named_parameters->tee( "SysExec'd: \"{$output['command']}\"" );

      return $this->_eval_compression_filter_exitcode( $output );
   }


   function str( $target, $strval, $options = array() )
   {
      $this->last_error("");

      if ( ($filecmd = $this->_build_compression_filter_cmd( $target, "", $options )) === false )
         return true; // error 

      $output = array();
      $options["stdin"] = &$strval; // this could be a huge string
      if ( ($r = sysexec( $output, $filecmd, $options )) !== false )
      {
         $this->last_error( "unable to exec process: \"{$filecmd}\"\n", true );

         // failed
         return $r;
      }

      $this->last_output = $output;

      if ( $this->debug_sysexec )
         $this->named_parameters->tee( "SysExec'd: \"{$output['command']}\"" );

      return $this->_eval_compression_filter_exitcode( $output );
   }

}


